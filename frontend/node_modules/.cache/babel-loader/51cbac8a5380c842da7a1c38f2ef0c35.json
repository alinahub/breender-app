{"ast":null,"code":"import _regeneratorRuntime from\"/Users/alinaturbina/Uni Projects/seba/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/alinaturbina/Uni Projects/seba/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{version}from'react';import ConversationService from'../../services/ConversationService';var ConversationTypes={GET_CONVERSATIONS:'GET_CONVERSATIONS',DELETE_CONVERSATION:'DELETE_CONVERSATION',UPDATE_CONVERSATION:'UPDATE_CONVERSATION',ADD_CONVERSATION:'ADD_CONVERSATION',GET_CONVERSATION:'GET_CONVERSATION'};export var addConversation=function addConversation(conversation){var addConversationAction=function addConversationAction(){return{type:ConversationTypes.ADD_CONVERSATION};};var onFailure=function onFailure(err){console.log(err);};return/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch){return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return ConversationService.createConversation(conversation).then(function(){dispatch(addConversationAction());}).catch(function(e){onFailure(e);});case 2:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}();};export var getConversations=function getConversations(userId){// when the backend call was successfull and the conversations are retrieved\n// in the dispatcher the conversations will be added to the global state\nvar onSuccess=function onSuccess(conversations){return{type:ConversationTypes.GET_CONVERSATIONS,conversations:conversations};};// when the backend call was failed\nvar onFailure=function onFailure(error){// error handling\nconsole.log('failed to get the conversations',error);};return/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dispatch,getState){var conversations;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return ConversationService.getConversations(userId);case 3:conversations=_context2.sent;// call onSuccess in context of redux\ndispatch(onSuccess(conversations));_context2.next=10;break;case 7:_context2.prev=7;_context2.t0=_context2[\"catch\"](0);onFailure(_context2.t0);case 10:case\"end\":return _context2.stop();}}},_callee2,null,[[0,7]]);}));return function(_x2,_x3){return _ref2.apply(this,arguments);};}();};export var getConversation=function getConversation(id1,id2){// when the backend call was successfull and the conversation are retrieved\n// in the dispatcher the conversation will be added to the global state\nvar onSuccess=function onSuccess(conversation){return{type:ConversationTypes.GET_CONVERSATION,conversation:conversation};};// when the backend call was failed\nvar onFailure=function onFailure(error){// error handling\nconsole.log('failed to get the conversation',error);};return/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(dispatch,getState){var conversation;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;_context3.next=3;return ConversationService.getConversation(id1,id2);case 3:conversation=_context3.sent;// call onSuccess in context of redux\ndispatch(onSuccess(conversation));_context3.next=10;break;case 7:_context3.prev=7;_context3.t0=_context3[\"catch\"](0);onFailure(_context3.t0);case 10:case\"end\":return _context3.stop();}}},_callee3,null,[[0,7]]);}));return function(_x4,_x5){return _ref3.apply(this,arguments);};}();};export var getOrAddConversation=function getOrAddConversation(id1,id2){// when the backend call was successfull and the conversations are retrieved\n// in the dispatcher the conversations will be added to the global state\nvar onSuccess=function onSuccess(conversation){return{type:ConversationTypes.GET_CONVERSATION,conversation:conversation};};// when the backend call was failed\nvar onFailure=function onFailure(error){// error handling\nconsole.log('failed to get the conversation',error);};return/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dispatch,getState){var conversation;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.prev=0;_context4.next=3;return ConversationService.getOrCreateConversation(id1,id2);case 3:conversation=_context4.sent;// call onSuccess in context of redux\ndispatch(onSuccess(conversation));_context4.next=10;break;case 7:_context4.prev=7;_context4.t0=_context4[\"catch\"](0);onFailure(_context4.t0);case 10:case\"end\":return _context4.stop();}}},_callee4,null,[[0,7]]);}));return function(_x6,_x7){return _ref4.apply(this,arguments);};}();};","map":{"version":3,"sources":["/Users/alinaturbina/Uni Projects/seba/frontend/src/redux/actions/conversationActions.js"],"names":["version","ConversationService","ConversationTypes","GET_CONVERSATIONS","DELETE_CONVERSATION","UPDATE_CONVERSATION","ADD_CONVERSATION","GET_CONVERSATION","addConversation","conversation","addConversationAction","type","onFailure","err","console","log","dispatch","createConversation","then","catch","e","getConversations","userId","onSuccess","conversations","error","getState","getConversation","id1","id2","getOrAddConversation","getOrCreateConversation"],"mappings":"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","sourcesContent":["import { version } from 'react';\nimport ConversationService from '../../services/ConversationService';\n\nconst ConversationTypes = {\n    GET_CONVERSATIONS: 'GET_CONVERSATIONS',\n    DELETE_CONVERSATION: 'DELETE_CONVERSATION',\n    UPDATE_CONVERSATION: 'UPDATE_CONVERSATION',\n    ADD_CONVERSATION: 'ADD_CONVERSATION',\n    GET_CONVERSATION: 'GET_CONVERSATION',\n};\n\nexport const addConversation = (conversation) => {\n    const addConversationAction = () => {\n        return { type: ConversationTypes.ADD_CONVERSATION };\n    };\n    const onFailure = (err) => {\n        console.log(err);\n    };\n\n    return async (dispatch) => {\n        await ConversationService.createConversation(conversation)\n            .then(() => {\n                dispatch(addConversationAction());\n            })\n            .catch((e) => {\n                onFailure(e);\n            });\n    };\n};\n\nexport const getConversations = (userId) => {\n    // when the backend call was successfull and the conversations are retrieved\n    // in the dispatcher the conversations will be added to the global state\n    const onSuccess = (conversations) => {\n        return { type: ConversationTypes.GET_CONVERSATIONS, conversations: conversations };\n    };\n    // when the backend call was failed\n    const onFailure = (error) => {\n        // error handling\n        console.log('failed to get the conversations', error);\n    };\n\n    return async (dispatch, getState) => {\n        try {\n            // ask for the conversations in the backend\n            let conversations = await ConversationService.getConversations(userId);\n            // call onSuccess in context of redux\n            dispatch(onSuccess(conversations));\n        } catch (e) {\n            onFailure(e);\n        }\n    };\n};\n\nexport const getConversation = (id1, id2) => {\n    // when the backend call was successfull and the conversation are retrieved\n    // in the dispatcher the conversation will be added to the global state\n    const onSuccess = (conversation) => {\n        return { type: ConversationTypes.GET_CONVERSATION, conversation };\n    };\n    // when the backend call was failed\n    const onFailure = (error) => {\n        // error handling\n        console.log('failed to get the conversation', error);\n    };\n\n    return async (dispatch, getState) => {\n        try {\n            // ask for the conversation in the backend\n            let conversation = await ConversationService.getConversation(id1, id2);\n            // call onSuccess in context of redux\n            dispatch(onSuccess(conversation));\n        } catch (e) {\n            onFailure(e);\n        }\n    };\n};\n\nexport const getOrAddConversation = (id1, id2) => {\n    // when the backend call was successfull and the conversations are retrieved\n    // in the dispatcher the conversations will be added to the global state\n    const onSuccess = (conversation) => {\n        return { type: ConversationTypes.GET_CONVERSATION, conversation: conversation };\n    };\n    // when the backend call was failed\n    const onFailure = (error) => {\n        // error handling\n        console.log('failed to get the conversation', error);\n    };\n\n    return async (dispatch, getState) => {\n        try {\n            // ask for the conversations in the backend\n            let conversation = await ConversationService.getOrCreateConversation(id1, id2);\n            // call onSuccess in context of redux\n            dispatch(onSuccess(conversation));\n        } catch (e) {\n            onFailure(e);\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}